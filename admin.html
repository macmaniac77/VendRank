<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard - Boathouse ELO</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        table { border-collapse: collapse; width: 100%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; cursor: pointer; }
        th:hover { background-color: #e8e8e8; }
        .bar-container { display: flex; height: 20px; width: 100%; background-color: #eee; border-radius: 4px; overflow: hidden; }
        .bar-r { background-color: #4A90E2; /* Blue */ height: 100%; transition: width 0.3s ease-in-out; }
        .bar-v { background-color: #7ED321; /* Green */ height: 100%; transition: width 0.3s ease-in-out; }
        .text-number { text-align: right; }
    </style>
</head>
<body>
    <div id="admin-dashboard">
        <h1>Admin Dashboard</h1>
        <div id="table-container">
            <p>Loading data...</p>
        </div>
    </div>

    <script>
        let currentSortColumn = 'composite';
        let currentSortDirection = 'desc';
        let originalItems = [];
        const SCORING_WEIGHT_R = 0.6; // Hardcoded as process.env is not available client-side
        const SCORING_WEIGHT_V = 0.4; // Hardcoded

        document.addEventListener('DOMContentLoaded', () => {
            fetchData();
        });

        async function fetchData() {
            try {
                const response = await fetch('/api/jsonbin?admin=true');
                if (!response.ok) {
                    throw new Error(`Failed to fetch data: ${response.status} ${response.statusText}`);
                }
                const itemsObject = await response.json(); // Expect an object from the API
                // The API returns an object where keys are item names/IDs and values are item objects.
                // Convert this to an array of items for table processing.
                if (typeof itemsObject !== 'object' || itemsObject === null) {
                    throw new Error('Data format error: Expected an object containing items.');
                }
                const itemsArray = Object.values(itemsObject);
                if (!Array.isArray(itemsArray)) { // Should be an array after Object.values
                     throw new Error('Data format error: Failed to convert items object to array.');
                }
                originalItems = itemsArray;
                renderTable(itemsArray);
            } catch (error) {
                document.getElementById('table-container').innerHTML = '<p>Error loading data: ' + error.message + '</p>';
                console.error(error);
            }
        }

        function renderTable(items) {
            const tableContainer = document.getElementById('table-container');
            tableContainer.innerHTML = ''; // Clear previous table/loading message

            const sortedItems = [...items].sort((a, b) => {
                let valA = a[currentSortColumn];
                let valB = b[currentSortColumn];

                // Handle specific types for sorting
                if (typeof valA === 'string' && !isNaN(parseFloat(valA))) valA = parseFloat(valA);
                if (typeof valB === 'string' && !isNaN(parseFloat(valB))) valB = parseFloat(valB);
                
                // Ensure numeric comparison for specific columns, defaulting undefined/null to 0
                if (['price', 'cost', 'elo', 'profitVelocity', 'composite', 'scaledR', 'scaledV'].includes(currentSortColumn)) {
                    valA = parseFloat(valA || 0);
                    valB = parseFloat(valB || 0);
                }


                if (valA < valB) return currentSortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return currentSortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            const headers = [
                { key: 'name', display: 'Name' },
                { key: 'slot', display: 'Slot' },
                { key: 'price', display: 'Price' },
                { key: 'cost', display: 'Cost' },
                { key: 'elo', display: 'ELO' },
                { key: 'profitVelocity', display: 'Profit Vel.' },
                { key: 'scaledR', display: 'Scaled R' },
                { key: 'scaledV', display: 'Scaled V' },
                { key: 'composite', display: 'Composite' },
                { key: 'composition', display: 'R/V Contribution' }
            ];

            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header.display;
                th.dataset.key = header.key;
                if (['price', 'cost', 'elo', 'profitVelocity', 'composite', 'scaledR', 'scaledV'].includes(header.key)) {
                    th.classList.add('text-number');
                }
                th.addEventListener('click', () => setSort(header.key));
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            sortedItems.forEach(item => {
                const tr = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    if (header.key === 'composition') {
                        const rValue = parseFloat(item.scaledR || 0);
                        const vValue = parseFloat(item.scaledV || 0);
                        
                        const rComponent = rValue * SCORING_WEIGHT_R;
                        const vComponent = vValue * SCORING_WEIGHT_V;
                        const totalComponentSum = rComponent + vComponent;

                        const rPercent = totalComponentSum > 0 ? (rComponent / totalComponentSum) * 100 : 0;
                        const vPercent = totalComponentSum > 0 ? (vComponent / totalComponentSum) * 100 : 0;

                        td.innerHTML = `<div class="bar-container" title="R: ${rComponent.toFixed(3)} (${(rPercent).toFixed(1)}%), V: ${vComponent.toFixed(3)} (${(vPercent).toFixed(1)}%)"><div class="bar-r" style="width: ${rPercent}%;"></div><div class="bar-v" style="width: ${vPercent}%;"></div></div>`;
                    } else if (['profitVelocity', 'composite', 'scaledR', 'scaledV'].includes(header.key)) {
                        td.textContent = parseFloat(item[header.key] || 0).toFixed(3);
                        td.classList.add('text-number');
                    } else if (['price', 'cost', 'elo'].includes(header.key)) {
                        // Ensure ELO is displayed as a whole number if it's an integer, or with decimals if not.
                        // Price and cost usually have two decimal places.
                        let value = item[header.key];
                        if (header.key === 'elo') {
                            td.textContent = parseFloat(value || 0).toString(); // Keep as string to show integer ELOs correctly
                        } else { // price, cost
                            td.textContent = parseFloat(value || 0).toFixed(2);
                        }
                        td.classList.add('text-number');
                    }
                    else {
                        td.textContent = item[header.key];
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            tableContainer.appendChild(table);
        }

        function setSort(key) {
            if (currentSortColumn === key) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = key;
                // Default to descending for numeric scores, ascending for names/slots
                if (['name', 'slot'].includes(key)) {
                    currentSortDirection = 'asc';
                } else {
                    currentSortDirection = 'desc';
                }
            }
            renderTable(originalItems); // Use originalItems to re-sort and re-render
        }
    </script>
</body>
</html>
